<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf8">
        <!--

             @license twgl.js Copyright (c) 2015, Gregg Tavares All Rights Reserved.
             Available via the MIT license.
             see: http://github.com/greggman/twgl.js for details

           -->
        <title>twgl.js - twgl cube</title>
        <style>
         body {
             margin: 0;
             font-family: monospace;
         }
         canvas {
             display: block;
             width: 100vw;
             height: 100vh;
         }
        </style>
    </head>
    <body>
        <canvas id="c"></canvas>
    </body>
    <script id="vs" type="notjs">
     /*
        uniform - change per primitive
        attribute - change per vertex
        varying - interpolated data between a vertex shader and a fragment shader
      */
     uniform mat4 u_worldViewProjection;
     uniform vec3 u_lightWorldPos;
     uniform mat4 u_world;
     uniform mat4 u_viewInverse;
     uniform mat4 u_worldInverseTranspose;

     attribute vec4 a_position;
     attribute vec3 a_normal;
     attribute vec2 a_texcoord;

     varying vec4 v_position;
     varying vec2 v_texCoord;
     varying vec3 v_normal;
     varying vec3 v_surfaceToLight;
     varying vec3 v_surfaceToView;

     void main() {
         v_texCoord = a_texcoord;
         v_position = (u_worldViewProjection * a_position);
         v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;
         v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;
         v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;
         gl_Position = v_position;
     }
    </script>
    <script id="fs" type="notjs">
     precision mediump float;

     varying vec4 v_position;
     varying vec2 v_texCoord;
     varying vec3 v_normal;
     varying vec3 v_surfaceToLight;
     varying vec3 v_surfaceToView;

     uniform vec4 u_lightColor;
     uniform vec4 u_ambient;
     uniform sampler2D u_diffuse;
     uniform vec4 u_specular;
     uniform float u_shininess;
     uniform float u_specularFactor;

     vec4 lit(float l ,float h, float m) {
         return vec4(1.0,
                     max(l, 0.0),
                     (l > 0.0) ? pow(max(0.0, h), m) : 0.0,
                     1.0);
     }

     void main() {
         vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);
         vec3 a_normal = normalize(v_normal);
         vec3 surfaceToLight = normalize(v_surfaceToLight);
         vec3 surfaceToView = normalize(v_surfaceToView);
         vec3 halfVector = normalize(surfaceToLight + surfaceToView);
         vec4 litR = lit(dot(a_normal, surfaceToLight),
                         dot(a_normal, halfVector), u_shininess);
         vec4 outColor = vec4((
             u_lightColor * (diffuseColor * litR.y + diffuseColor * u_ambient +
                             u_specular * litR.z * u_specularFactor)).rgb,
                              diffuseColor.a);
         gl_FragColor = outColor;
     }
    </script>
    <script src="twgl-full.js"></script>
    <script>
     "use strict";
     twgl.setDefaults({attribPrefix: "a_"});
     var m4 = twgl.m4;
     var gl = twgl.getWebGLContext(document.getElementById("c"));
     var programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);

     var arrays = {
         position: [
             1, 1, -1,
             1, 1, 1,
             1, -1, 1,
             1, -1, -1,
             -1, 1, 1, // 5
             -1, 1, -1,
             -1, -1, -1,
             -1, -1, 1,
             -1, 1, 1,
             1, 1, 1, // 10
             1, 1, -1,
             -1, 1, -1,
             -1, -1, -1,
             1, -1, -1,
             1, -1, 1, // 15
             -1, -1, 1,
             1, 1, 1,
             -1, 1, 1,
             -1, -1, 1,
             1, -1, 1, // 20
             -1, 1, -1,
             1, 1, -1,
             1, -1, -1,
             -1, -1, -1],
         normal:   [
             1, 0, 0,
             1, 0, 0,
             1, 0, 0,
             1, 0, 0,
             -1, 0, 0, // 5
             -1, 0, 0,
             -1, 0, 0,
             -1, 0, 0,
             0, 1, 0,
             0, 1, 0, // 10
             0, 1, 0,
             0, 1, 0,
             0, -1, 0,
             0, -1, 0,
             0, -1, 0, // 15
             0, -1, 0,
             0, 0, 1,
             0, 0, 1,
             0, 0, 1,
             0, 0, 1, // 20
             0, 0, -1,
             0, 0, -1,
             0, 0, -1,
             0, 0, -1],
         texcoord: [
             1, 0,
             0, 0,
             0, 1,
             1, 1,
             1, 0, // 5
             0, 0,
             0, 1,
             1, 1,
             1, 0,
             0, 0, // 10
             0, 1,
             1, 1,
             1, 0,
             0, 0,
             0, 1, // 15
             1, 1,
             1, 0,
             0, 0,
             0, 1,
             1, 1, // 20
             1, 0,
             0, 0,
             0, 1,
             1, 1],
         indices:  [
             0, 1, 2,
             0, 2, 3,
             4, 5, 6,
             4, 6, 7,
             8, 9, 10,
             8, 10, 11,
             12, 13, 14,
             12, 14, 15,
             16, 17, 18,
             16, 18, 19,
             20, 21, 22,
             20, 22, 23],
     };
     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays); // create buffer, multiple buffer ?

     var tex = twgl.createTexture(gl, {
         min: gl.NEAREST,
         mag: gl.NEAREST,
         src: [
             255, 255, 255, 255,
             192, 192, 192, 255,
             192, 255, 192, 255,
             255, 192, 255, 255,
         ],
     }); // create texture, min? mag? last param not alpha?

     var uniforms = {
         u_lightWorldPos: [1, 8, -10],
         u_lightColor: [1, 0.8, 0.8, 1],
         u_ambient: [0, 0, 0, 1],
         u_specular: [1, 1, 1, 1],
         u_shininess: 50,
         u_specularFactor: 1,
         u_diffuse: tex,
     }; // uniform values for shaders, only 1 light source?

     function render(time) {
         time *= 0.001;
         twgl.resizeCanvasToDisplaySize(gl.canvas);
         gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

         gl.enable(gl.DEPTH_TEST);
         gl.enable(gl.CULL_FACE);
         gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

         var eye = [1, 4, -6];
         var target = [0, 0, 0];
         var up = [0, 1, 0];

         var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 10); // in case of screen resize
         var camera = m4.lookAt(eye, target, up);
         var view = m4.inverse(camera);
         var viewProjection = m4.multiply(projection, view);
         var world = m4.rotationY(time);

         // some uniform adjustment (camera and world)
         uniforms.u_viewInverse = camera;
         uniforms.u_world = world;
         uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(world));
         uniforms.u_worldViewProjection = m4.multiply(viewProjection, world);

         gl.useProgram(programInfo.program);
         twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
         twgl.setUniforms(programInfo, uniforms);
         gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);

         requestAnimationFrame(render);
     }
     requestAnimationFrame(render);

    </script>
</html>
